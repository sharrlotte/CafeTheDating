{
  "version": 3,
  "sources": ["../../../../src/services/users.service.ts"],
  "sourcesContent": ["import { databaseService } from './database.service'\r\nimport { TokenType, UserRole } from '@/constants/enums'\r\nimport { env } from '@/config/environment.config'\r\nimport { RefreshTokenBody } from '@/models/requests/User.requests'\r\nimport RefreshToken from '@/models/schemas/RefreshToken.schema'\r\nimport { ObjectId } from 'mongodb'\r\nimport { PaginationType, ResultRefreshTokenType } from '@/@types/reponse.type'\r\nimport User from '@/models/schemas/Users.schema'\r\nimport { ErrorWithStatus } from '@/models/errors/Errors.schema'\r\nimport { StatusCodes } from 'http-status-codes'\r\nimport { VALIDATION_MESSAGES } from '@/constants/message'\r\nimport { ParsedUrlQuery } from 'querystring'\r\nimport _ from 'lodash'\r\nimport { signToken } from '@/utils/jwt'\r\nimport { verifyToken } from '@/utils/jwt'\r\n\r\nclass UserService {\r\n  async validateRefreshToken(refresh_token: string) {\r\n    const token = await databaseService.refreshTokens.findOne({ token: refresh_token })\r\n    return Boolean(token)\r\n  }\r\n\r\n  signAccessToken(_id: string, email: string, role: UserRole) {\r\n    let { access_token_exp, jwt_algorithm, secret_key } = env.jwt\r\n    return signToken({\r\n      payload: {\r\n        _id,\r\n        email,\r\n        role,\r\n        token_type: TokenType.AccessToken\r\n      },\r\n      privateKey: secret_key as string,\r\n      options: {\r\n        expiresIn: access_token_exp,\r\n        algorithm: jwt_algorithm\r\n      }\r\n    })\r\n  }\r\n\r\n  signRefreshToken(_id: string, email: string, role: UserRole) {\r\n    let { refresh_token_exp, jwt_algorithm, refresh_token_key } = env.jwt\r\n    return signToken({\r\n      payload: {\r\n        _id,\r\n        email,\r\n        role,\r\n        token_type: TokenType.RefreshToken\r\n      },\r\n      privateKey: refresh_token_key as string,\r\n      options: {\r\n        expiresIn: refresh_token_exp,\r\n        algorithm: jwt_algorithm\r\n      }\r\n    })\r\n  }\r\n  // Create access_token and refresh_token\r\n  signAccessAndRefreshToken(user_id: string, email: string, role: UserRole) {\r\n    return Promise.all([this.signAccessToken(user_id, email, role), this.signRefreshToken(user_id, email, role)])\r\n  }\r\n\r\n  async refreshToken(payload: RefreshTokenBody) {\r\n    const { refresh_token } = payload\r\n    const { refresh_token_key } = env.jwt\r\n\r\n    const { _id, role, email } = await verifyToken({\r\n      token: refresh_token,\r\n      secretOrPublicKey: refresh_token_key\r\n    })\r\n\r\n    const deleteRefreshToken = databaseService.refreshTokens.deleteOne({ user_id: _id })\r\n    const signToken = this.signAccessAndRefreshToken(_id, email, role)\r\n\r\n    const [tokens] = await Promise.all([signToken, deleteRefreshToken])\r\n\r\n    const [newAccessToken, newRefreshToken] = tokens\r\n\r\n    await databaseService.refreshTokens.insertOne(\r\n      new RefreshToken({\r\n        token: refresh_token,\r\n        user_id: new ObjectId(_id)\r\n      })\r\n    )\r\n\r\n    const result: ResultRefreshTokenType = { access_token: newAccessToken, refresh_token: newRefreshToken }\r\n    return result\r\n  }\r\n\r\n  async getAllUser(payload: ParsedUrlQuery) {\r\n    const pageIndex = Number(payload.pageIndex)\r\n    const pageSize = Number(payload.pageSize)\r\n    const query = String(payload.query ?? ' ')\r\n    const role = String(payload.role) as UserRole\r\n\r\n    // TODO: Use text search index\r\n    const users = await databaseService.users\r\n      .find({ username: { $regex: query }, role })\r\n      .limit(pageSize)\r\n      .skip((pageIndex - 1) * pageSize)\r\n      .toArray()\r\n\r\n    const totalPage = Math.ceil((await databaseService.users.countDocuments({ username: { $regex: query }, role })) / pageSize)\r\n\r\n    // TODO: Make something like private attributes const in UserType\r\n    const filteredUsers = _.map(users, (v) => _.omit(v, ['password', 'created_at', 'updated_at', 'email', 'phone', 'forgot_password_token', 'verify', '_destroy', 'password_change_at']))\r\n\r\n    const result: PaginationType<Partial<User>> = {\r\n      items: filteredUsers,\r\n      pageIndex: pageIndex,\r\n      pageSize: pageSize,\r\n      totalRow: filteredUsers.length,\r\n      totalPage: totalPage\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  async getUserByID(id: ObjectId) {\r\n    const user = await databaseService.users.findOne({ _id: id })\r\n    if (!user) {\r\n      throw new ErrorWithStatus({\r\n        statusCode: StatusCodes.NOT_FOUND,\r\n        message: VALIDATION_MESSAGES.USER.COMMONS.USER_WITH_ID_IS_NOT_EXIST\r\n      })\r\n    }\r\n\r\n    return _.omit(user, ['updated_at', 'created_at'])\r\n  }\r\n\r\n  async changeRole(id: string, role: UserRole) {\r\n    return await databaseService.users.updateOne(\r\n      { _id: new ObjectId(id) },\r\n      {\r\n        $set: {\r\n          role: role\r\n        }\r\n      },\r\n      { upsert: false }\r\n    )\r\n  }\r\n}\r\n\r\nconst userServices = new UserService()\r\nexport default userServices\r\n"],
  "mappings": "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",
  "names": ["import_jwt", "signToken", "RefreshToken", "_"]
}
